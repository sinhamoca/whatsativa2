// message-converter.js - Utilit√°rio para Converter Mensagens Personalizadas para Padr√£o
const DatabaseService = require('./database-service');
const fs = require('fs');
const path = require('path');

class MessageConverter {
    constructor() {
        this.db = new DatabaseService('./database.sqlite');
        this.backupDir = path.join(__dirname, 'backups');
    }

    async initialize() {
        await this.db.initialize();
        
        // Criar diret√≥rio de backup se n√£o existir
        if (!fs.existsSync(this.backupDir)) {
            fs.mkdirSync(this.backupDir, { recursive: true });
        }
    }

    async close() {
        await this.db.close();
    }

    /**
     * Criar backup do banco antes das modifica√ß√µes
     */
    async createBackup() {
        try {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const backupFileName = `database-backup-${timestamp}.sqlite`;
            const backupPath = path.join(this.backupDir, backupFileName);
            
            // Copiar arquivo do banco
            fs.copyFileSync('./database.sqlite', backupPath);
            
            console.log(`‚úÖ Backup criado: ${backupFileName}`);
            console.log(`üìÅ Local: ${backupPath}`);
            
            return backupPath;
            
        } catch (error) {
            console.error('‚ùå Erro ao criar backup:', error.message);
            throw error;
        }
    }

    /**
     * Listar todos os produtos com mensagens personalizadas
     */
    async listProductsWithCustomMessages() {
        try {
            const products = await this.db.getProducts();
            const customProducts = products.filter(product => product.paymentConfirmedMessage);
            
            console.log(`\nüì± PRODUTOS COM MENSAGENS PERSONALIZADAS: ${customProducts.length}`);
            console.log('‚ïê'.repeat(80));
            
            if (customProducts.length === 0) {
                console.log('‚úÖ Nenhum produto possui mensagem personalizada.');
                return [];
            }
            
            customProducts.forEach((product, index) => {
                console.log(`\n${index + 1}. üéØ ${product.name.toUpperCase()}`);
                console.log('‚îÄ'.repeat(50));
                console.log(`üìã ID: ${product.id}`);
                console.log(`üí∞ Pre√ßo: R$ ${product.price.toFixed(2)}`);
                console.log(`‚öôÔ∏è M√≥dulo: ${product.activationModule}`);
                console.log(`üîß Status: ${product.active ? 'ATIVO' : 'INATIVO'}`);
                
                // Preview da mensagem personalizada
                const messagePreview = product.paymentConfirmedMessage.length > 150 
                    ? product.paymentConfirmedMessage.substring(0, 150) + '...' 
                    : product.paymentConfirmedMessage;
                
                console.log(`üí¨ Mensagem Atual:`);
                console.log(`   ${messagePreview.replace(/\n/g, '\\n')}`);
            });
            
            return customProducts;
            
        } catch (error) {
            console.error('‚ùå Erro ao listar produtos:', error.message);
            return [];
        }
    }

    /**
     * Obter mensagem padr√£o do sistema
     */
    async getDefaultMessage() {
        try {
            const messages = await this.db.getMessages();
            return messages.payment_confirmed || '‚úÖ *Pagamento confirmado!*\n\nüéØ {product_name}\nüí∞ R$ {price}\n\nüìù *Envie as informa√ß√µes para ativa√ß√£o.*';
        } catch (error) {
            console.error('‚ùå Erro ao obter mensagem padr√£o:', error.message);
            return '‚úÖ *Pagamento confirmado!*\n\nüéØ {product_name}\nüí∞ R$ {price}\n\nüìù *Envie as informa√ß√µes para ativa√ß√£o.*';
        }
    }

    /**
     * Converter um produto espec√≠fico para mensagem padr√£o
     */
    async convertSingleProduct(productId) {
        try {
            const product = await this.db.getProduct(productId);
            
            if (!product) {
                console.log(`‚ùå Produto ${productId} n√£o encontrado.`);
                return false;
            }
            
            if (!product.paymentConfirmedMessage) {
                console.log(`‚úÖ Produto ${product.name} j√° usa mensagem padr√£o.`);
                return true;
            }
            
            // Salvar mensagem atual como backup
            const backup = {
                productId: productId,
                productName: product.name,
                originalMessage: product.paymentConfirmedMessage,
                convertedAt: new Date().toISOString()
            };
            
            // Remover mensagem personalizada (definir como NULL)
            await this.db.run(
                'UPDATE products SET payment_confirmed_message = NULL WHERE id = ?',
                [productId]
            );
            
            console.log(`‚úÖ ${product.name} convertido para mensagem padr√£o`);
            
            return backup;
            
        } catch (error) {
            console.error(`‚ùå Erro ao converter produto ${productId}:`, error.message);
            return false;
        }
    }

    /**
     * Converter todos os produtos para mensagem padr√£o
     */
    async convertAllProducts(createBackup = true) {
        try {
            console.log('\nüîÑ INICIANDO CONVERS√ÉO PARA MENSAGEM PADR√ÉO');
            console.log('‚ïê'.repeat(60));
            
            // Criar backup se solicitado
            let backupPath = null;
            if (createBackup) {
                backupPath = await this.createBackup();
            }
            
            // Listar produtos com mensagem personalizada
            const customProducts = await this.listProductsWithCustomMessages();
            
            if (customProducts.length === 0) {
                console.log('\n‚úÖ Nada para converter!');
                return {
                    converted: 0,
                    skipped: 0,
                    errors: 0,
                    backup: backupPath
                };
            }
            
            // Obter mensagem padr√£o
            const defaultMessage = await this.getDefaultMessage();
            console.log(`\nüìù MENSAGEM PADR√ÉO QUE SER√Å USADA:`);
            console.log('‚îÄ'.repeat(50));
            console.log(defaultMessage);
            console.log('‚îÄ'.repeat(50));
            
            // Confirmar convers√£o
            if (!await this.confirmConversion(customProducts.length)) {
                console.log('\n‚ùå Convers√£o cancelada pelo usu√°rio.');
                return null;
            }
            
            // Executar convers√£o
            const results = {
                converted: 0,
                skipped: 0,
                errors: 0,
                backup: backupPath,
                conversions: []
            };
            
            console.log('\nüîÑ EXECUTANDO CONVERS√ïES...');
            console.log('‚îÄ'.repeat(40));
            
            for (const product of customProducts) {
                try {
                    const backup = await this.convertSingleProduct(product.id);
                    
                    if (backup === true) {
                        results.skipped++;
                    } else if (backup) {
                        results.converted++;
                        results.conversions.push(backup);
                    } else {
                        results.errors++;
                    }
                    
                } catch (error) {
                    console.error(`‚ùå Erro ao converter ${product.name}:`, error.message);
                    results.errors++;
                }
            }
            
            // Salvar backup das mensagens convertidas
            if (results.conversions.length > 0) {
                await this.saveConversionsBackup(results.conversions);
            }
            
            // Mostrar resultado
            this.displayResults(results);
            
            return results;
            
        } catch (error) {
            console.error('‚ùå Erro na convers√£o:', error.message);
            return null;
        }
    }

    /**
     * Confirmar convers√£o com o usu√°rio
     */
    async confirmConversion(count) {
        return new Promise((resolve) => {
            const readline = require('readline');
            const rl = readline.createInterface({
                input: process.stdin,
                output: process.stdout
            });
            
            console.log(`\n‚ö†Ô∏è ATEN√á√ÉO: Voc√™ est√° prestes a converter ${count} produtos!`);
            console.log('   Todas as mensagens personalizadas ser√£o removidas.');
            console.log('   Um backup ser√° criado automaticamente.');
            
            rl.question('\nü§î Deseja continuar? (s/N): ', (answer) => {
                rl.close();
                const confirmed = answer.toLowerCase() === 's' || answer.toLowerCase() === 'sim';
                resolve(confirmed);
            });
        });
    }

    /**
     * Salvar backup das convers√µes
     */
    async saveConversionsBackup(conversions) {
        try {
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const backupFileName = `conversions-backup-${timestamp}.json`;
            const backupPath = path.join(this.backupDir, backupFileName);
            
            const backupData = {
                timestamp: new Date().toISOString(),
                totalConversions: conversions.length,
                conversions: conversions
            };
            
            fs.writeFileSync(backupPath, JSON.stringify(backupData, null, 2));
            
            console.log(`\nüíæ Backup das mensagens salvo: ${backupFileName}`);
            
        } catch (error) {
            console.error('‚ùå Erro ao salvar backup das mensagens:', error.message);
        }
    }

    /**
     * Exibir resultados da convers√£o
     */
    displayResults(results) {
        console.log('\nüéØ RESULTADOS DA CONVERS√ÉO');
        console.log('‚ïê'.repeat(40));
        console.log(`‚úÖ Convertidos: ${results.converted}`);
        console.log(`‚è≠Ô∏è Ignorados: ${results.skipped}`);
        console.log(`‚ùå Erros: ${results.errors}`);
        
        if (results.backup) {
            console.log(`üíæ Backup: ${path.basename(results.backup)}`);
        }
        
        if (results.converted > 0) {
            console.log(`\nüéâ ${results.converted} produtos agora usam mensagem padr√£o!`);
            console.log('üìù Para restaurar, use o arquivo de backup gerado.');
        }
    }

    /**
     * Restaurar mensagens de um backup
     */
    async restoreFromBackup(backupFilePath) {
        try {
            console.log('\nüîÑ RESTAURANDO MENSAGENS DO BACKUP');
            console.log('‚ïê'.repeat(50));
            
            if (!fs.existsSync(backupFilePath)) {
                console.log(`‚ùå Arquivo de backup n√£o encontrado: ${backupFilePath}`);
                return false;
            }
            
            const backupData = JSON.parse(fs.readFileSync(backupFilePath, 'utf8'));
            
            console.log(`üìÑ Backup de: ${new Date(backupData.timestamp).toLocaleString('pt-BR')}`);
            console.log(`üìä Mensagens para restaurar: ${backupData.totalConversions}`);
            
            // Confirmar restaura√ß√£o
            if (!await this.confirmRestore(backupData.totalConversions)) {
                console.log('\n‚ùå Restaura√ß√£o cancelada.');
                return false;
            }
            
            let restored = 0;
            let errors = 0;
            
            for (const conversion of backupData.conversions) {
                try {
                    await this.db.run(
                        'UPDATE products SET payment_confirmed_message = ? WHERE id = ?',
                        [conversion.originalMessage, conversion.productId]
                    );
                    
                    console.log(`‚úÖ ${conversion.productName} restaurado`);
                    restored++;
                    
                } catch (error) {
                    console.error(`‚ùå Erro ao restaurar ${conversion.productName}:`, error.message);
                    errors++;
                }
            }
            
            console.log('\nüéØ RESULTADO DA RESTAURA√á√ÉO');
            console.log('‚îÄ'.repeat(30));
            console.log(`‚úÖ Restaurados: ${restored}`);
            console.log(`‚ùå Erros: ${errors}`);
            
            return restored > 0;
            
        } catch (error) {
            console.error('‚ùå Erro na restaura√ß√£o:', error.message);
            return false;
        }
    }

    /**
     * Confirmar restaura√ß√£o
     */
    async confirmRestore(count) {
        return new Promise((resolve) => {
            const readline = require('readline');
            const rl = readline.createInterface({
                input: process.stdin,
                output: process.stdout
            });
            
            rl.question(`\nü§î Restaurar ${count} mensagens personalizadas? (s/N): `, (answer) => {
                rl.close();
                const confirmed = answer.toLowerCase() === 's' || answer.toLowerCase() === 'sim';
                resolve(confirmed);
            });
        });
    }

    /**
     * Listar backups dispon√≠veis
     */
    listBackups() {
        try {
            if (!fs.existsSync(this.backupDir)) {
                console.log('üìÅ Nenhum backup encontrado.');
                return [];
            }
            
            const files = fs.readdirSync(this.backupDir);
            const backupFiles = files.filter(file => 
                file.startsWith('conversions-backup-') && file.endsWith('.json')
            );
            
            console.log('\nüíæ BACKUPS DISPON√çVEIS:');
            console.log('‚ïê'.repeat(40));
            
            if (backupFiles.length === 0) {
                console.log('Nenhum backup de convers√µes encontrado.');
                return [];
            }
            
            backupFiles.forEach((file, index) => {
                const filePath = path.join(this.backupDir, file);
                const stats = fs.statSync(filePath);
                
                try {
                    const data = JSON.parse(fs.readFileSync(filePath, 'utf8'));
                    console.log(`\n${index + 1}. ${file}`);
                    console.log(`   üìÖ Data: ${new Date(data.timestamp).toLocaleString('pt-BR')}`);
                    console.log(`   üìä Mensagens: ${data.totalConversions}`);
                    console.log(`   üìÅ Tamanho: ${Math.round(stats.size / 1024)} KB`);
                } catch (error) {
                    console.log(`\n${index + 1}. ${file} (arquivo corrompido)`);
                }
            });
            
            return backupFiles.map(file => path.join(this.backupDir, file));
            
        } catch (error) {
            console.error('‚ùå Erro ao listar backups:', error.message);
            return [];
        }
    }
}

/**
 * Fun√ß√µes de conveni√™ncia
 */

async function convertAll() {
    const converter = new MessageConverter();
    
    try {
        await converter.initialize();
        const result = await converter.convertAllProducts(true);
        return result;
    } catch (error) {
        console.error('‚ùå Erro:', error.message);
        return null;
    } finally {
        await converter.close();
    }
}

async function listCustom() {
    const converter = new MessageConverter();
    
    try {
        await converter.initialize();
        await converter.listProductsWithCustomMessages();
    } catch (error) {
        console.error('‚ùå Erro:', error.message);
    } finally {
        await converter.close();
    }
}

async function listBackups() {
    const converter = new MessageConverter();
    
    try {
        await converter.initialize();
        converter.listBackups();
    } catch (error) {
        console.error('‚ùå Erro:', error.message);
    } finally {
        await converter.close();
    }
}

async function restore(backupFile) {
    const converter = new MessageConverter();
    
    try {
        await converter.initialize();
        await converter.restoreFromBackup(backupFile);
    } catch (error) {
        console.error('‚ùå Erro:', error.message);
    } finally {
        await converter.close();
    }
}

// Executar se chamado diretamente
if (require.main === module) {
    const args = process.argv.slice(2);
    const command = args[0] || 'list';
    
    console.log('üîÑ CONVERSOR DE MENSAGENS');
    console.log('‚ïê'.repeat(40));
    
    switch (command) {
        case 'convert':
        case 'all':
            console.log('üîÑ Convertendo todas as mensagens para padr√£o...\n');
            convertAll();
            break;
            
        case 'restore':
            const backupFile = args[1];
            if (!backupFile) {
                console.log('‚ùå Especifique o arquivo de backup.');
                console.log('Uso: node message-converter.js restore [arquivo-backup]');
                console.log('\nBackups dispon√≠veis:');
                listBackups();
            } else {
                console.log(`üîÑ Restaurando do backup: ${backupFile}\n`);
                restore(backupFile);
            }
            break;
            
        case 'backups':
            console.log('üíæ Listando backups dispon√≠veis...\n');
            listBackups();
            break;
            
        case 'list':
        default:
            console.log('üìã Listando produtos com mensagens personalizadas...\n');
            listCustom();
            break;
    }
}

module.exports = {
    MessageConverter,
    convertAll,
    listCustom,
    listBackups,
    restore
};
