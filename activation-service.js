// activation-service.js - VERS√ÉO CORRIGIDA - Sistema de Cr√©ditos + SIL√äNCIO PROFUNDO
const pino = require('pino');

class ActivationService {
    constructor(config = {}) {
        this.config = {
            ...config
        };
        
        this.logger = pino({ level: 'info' });
        this.db = null;
        this.activationManager = null;
        this.whatsappHandler = null;
    }

    // Inicializar com depend√™ncias
    initialize(dependencies) {
        this.db = dependencies.db;
        this.activationManager = dependencies.activationManager;
        this.whatsappHandler = dependencies.whatsappHandler;
        
        this.logger.info('üîß Activation Service inicializado');
    }

    // üîß PROCESSAMENTO CORRIGIDO - Identifica produto correto no fluxo de cr√©dito + SIL√äNCIO PROFUNDO
    async processActivationInfo(chatId, activationData) {
        try {
            this.logger.info(`üîß PROCESSAMENTO CORRIGIDO - Ativa√ß√£o para ${chatId}`);
            
            const userSession = await this.db.getUserSession(chatId);
            
            // üîß NOVA L√ìGICA: Detectar se est√° no fluxo de cr√©dito
            const isUsingCredit = userSession.availableCredit > 0 && userSession.creditOrderId;
            
            this.logger.info(`üí≥ Status do usu√°rio: Cr√©dito=${userSession.availableCredit}, UsandoCr√©dito=${isUsingCredit}, CreditOrderId=${userSession.creditOrderId}, CurrentOrderId=${userSession.currentOrderId}`);
            
            let targetOrder;
            let selectedProduct;
            
            if (isUsingCredit) {
                // üîß FLUXO DE CR√âDITO: Produto foi selecionado recentemente
                this.logger.info(`üí≥ FLUXO DE CR√âDITO DETECTADO - Buscando produto selecionado`);
                
                // Buscar o pedido que gerou o cr√©dito
                const creditOrder = await this.db.getOrder(userSession.creditOrderId);
                
                if (!creditOrder) {
                    this.logger.error(`‚ùå Pedido de cr√©dito ${userSession.creditOrderId} n√£o encontrado`);
                    return { 
                        success: false,
                        reply: '‚ùå Erro na sess√£o de cr√©dito. Entre em contato com o suporte.' 
                    };
                }
                
                // üîß CORRE√á√ÉO CR√çTICA: Buscar qual produto foi REC√âM-SELECIONADO
                // Isso deveria estar armazenado na sess√£o quando o produto √© selecionado
                selectedProduct = await this.getLastSelectedProductFromSession(userSession);
                
                if (!selectedProduct) {
                    this.logger.error(`‚ùå Produto selecionado n√£o encontrado na sess√£o de ${chatId}`);
                    return { 
                        success: false,
                        reply: '‚ùå Erro: produto n√£o identificado. Digite *menu* para selecionar novamente.' 
                    };
                }
                
                // Criar um "pedido virtual" para a ativa√ß√£o com o produto correto
                targetOrder = {
                    id: creditOrder.id, // Usar ID do pedido original para tracking
                    chatId: chatId,
                    productId: selectedProduct.id,
                    product: selectedProduct, // üîß PRODUTO CORRETO!
                    status: 'paid', // J√° foi pago com cr√©dito
                    activationData: activationData,
                    isFromCredit: true
                };
                
                this.logger.info(`‚úÖ PRODUTO CORRETO IDENTIFICADO: ${selectedProduct.name} (ID: ${selectedProduct.id})`);
                
            } else {
                // üîß FLUXO NORMAL: Usar pedido atual
                this.logger.info(`üí∞ FLUXO NORMAL - Usando currentOrderId: ${userSession.currentOrderId}`);
                
                const orderId = userSession.currentOrderId;
                
                if (!orderId) {
                    this.logger.error(`‚ùå Nenhum pedido ativo para ${chatId}`);
                    return { 
                        success: false,
                        reply: '‚ùå Nenhum pedido ativo encontrado. Digite *menu* para come√ßar.' 
                    };
                }
                
                targetOrder = await this.db.getOrder(orderId);
                
                if (!targetOrder) {
                    this.logger.error(`‚ùå Pedido ${orderId} n√£o encontrado`);
                    return { 
                        success: false,
                        reply: '‚ùå Pedido n√£o encontrado.' 
                    };
                }

                // Verificar se √© um pedido pago
                if (targetOrder.status !== 'paid') {
                    this.logger.warn(`‚ö†Ô∏è Tentativa de ativa√ß√£o em pedido n√£o pago: ${orderId}`);
                    return { 
                        success: false,
                        reply: '‚ùå Pagamento ainda n√£o confirmado. Digite *verificar* para verificar o pagamento.' 
                    };
                }
                
                selectedProduct = targetOrder.product;
            }
            
            // üîß LOGS DETALHADOS PARA AUDITORIA
            this.logger.info(`üîß ATIVA√á√ÉO CONFIGURADA:`);
            this.logger.info(`   üì± Cliente: ${chatId}`);
            this.logger.info(`   üéØ Produto: ${selectedProduct.name} (ID: ${selectedProduct.id})`);
            this.logger.info(`   üõ†Ô∏è M√≥dulo: ${selectedProduct.activationModule}`);
            this.logger.info(`   üí≥ Usando cr√©dito: ${isUsingCredit}`);
            this.logger.info(`   üìã Dados: ${activationData.substring(0, 100)}...`);
            
            // üîá ATIVAR SIL√äNCIO PROFUNDO ANTES DA ATIVA√á√ÉO
            this.logger.info(`üîá ATIVANDO SIL√äNCIO para ${chatId} durante ativa√ß√£o de ${selectedProduct.name}`);
            userSession.state = 'processing_activation';
            await this.db.saveUserSession(chatId, userSession);
            
            // Atualizar dados de ativa√ß√£o (usar pedido original se for cr√©dito)
            if (isUsingCredit) {
                // Para cr√©dito, salvar dados no pedido original
                const originalOrder = await this.db.getOrder(userSession.creditOrderId);
                originalOrder.activationData = activationData;
                originalOrder.status = 'processing';
                // üîß CR√çTICO: Salvar qual produto foi REALMENTE selecionado
                originalOrder.selectedProductForActivation = {
                    id: selectedProduct.id,
                    name: selectedProduct.name,
                    activationModule: selectedProduct.activationModule
                };
                await this.db.saveOrder(originalOrder);
                
                this.logger.info(`üíæ Dados salvos no pedido original ${userSession.creditOrderId} com produto selecionado: ${selectedProduct.name}`);
            } else {
                // Fluxo normal
                targetOrder.activationData = activationData;
                targetOrder.status = 'processing';
                await this.db.saveOrder(targetOrder);
            }
            
            // Enviar confirma√ß√£o imediata para o usu√°rio
            const confirmationMessage = `üîÑ *INICIANDO ATIVA√á√ÉO*

üéØ **${selectedProduct.name}**
üìã Dados recebidos e verificados

‚è≥ *Processando ativa√ß√£o...*
Por favor aguarde o resultado final.

üîá *Sistema em modo silencioso*
N√£o responderemos at√© a conclus√£o.`;

            await this.whatsappHandler.sendMessage(chatId, confirmationMessage);
            
            // üîß ENVIAR PARA ATIVA√á√ÉO COM PRODUTO CORRETO EM BACKGROUND
            setImmediate(async () => {
                await this.sendToActivationModule(targetOrder);
            });
            
            return {
                success: true,
                reply: null // J√° enviou confirma√ß√£o acima
            };
            
        } catch (error) {
            this.logger.error('‚ùå Erro cr√≠tico no processamento de ativa√ß√£o:', error);
            
            // üîá DESATIVAR SIL√äNCIO EM CASO DE ERRO
            try {
                const userSession = await this.db.getUserSession(chatId);
                userSession.state = 'awaiting_activation_info';
                await this.db.saveUserSession(chatId, userSession);
            } catch (cleanupError) {
                this.logger.error('Erro ao limpar estado:', cleanupError);
            }
            
            return { 
                success: false, 
                reply: '‚ùå Erro interno. Tente novamente.' 
            };
        }
    }

    // üîß NOVO M√âTODO: Buscar produto selecionado na sess√£o
    async getLastSelectedProductFromSession(userSession) {
        try {
            // M√©todo 1: Verificar se foi salvo nos dados da sess√£o
            if (userSession.data && userSession.data.selectedProductId) {
                const productId = userSession.data.selectedProductId;
                const product = await this.db.getProduct(productId);
                
                if (product) {
                    this.logger.info(`‚úÖ Produto encontrado nos dados da sess√£o: ${product.name}`);
                    return product;
                }
            }
            
            // M√©todo 2: Para compatibilidade, tentar buscar o √∫ltimo produto selecionado
            // atrav√©s de logs ou outras fontes (implementar se necess√°rio)
            
            this.logger.warn(`‚ö†Ô∏è Produto selecionado n√£o encontrado na sess√£o`);
            return null;
            
        } catch (error) {
            this.logger.error('Erro ao buscar produto da sess√£o:', error);
            return null;
        }
    }

    // Enviar pedido para o m√≥dulo de ativa√ß√£o espec√≠fico
    async sendToActivationModule(order) {
        try {
            // üîß USAR PRODUTO CORRETO (pode ser diferente do produto original)
            const productToActivate = order.selectedProductForActivation || order.product;
            
            this.logger.info(`üöÄ INICIANDO ATIVA√á√ÉO:`);
            this.logger.info(`   üéØ Produto: ${productToActivate.name}`);
            this.logger.info(`   üõ†Ô∏è M√≥dulo: ${productToActivate.activationModule}`);
            this.logger.info(`   üìã Dados: ${order.activationData}`);
        
            const result = await this.activationManager.activateProduct({
                ...order,
                product: productToActivate // üîß Garantir produto correto
            }, order.activationData);
        
            this.logger.info(`üîß RESULTADO DA ATIVA√á√ÉO:`, result);
        
            await this.processActivationResult(order.id, result.success, result.result, result.error);
        
        } catch (error) {
            this.logger.error('‚ùå Erro na ativa√ß√£o:', error);
            await this.processActivationResult(order.id, false, null, error.message);
        }
    }
// Processar resultado da ativa√ß√£o + DESATIVAR SIL√äNCIO - VERS√ÉO CORRIGIDA
    async processActivationResult(orderId, success, result, error = null) {
        try {
            this.logger.info(`üîß Processando resultado da ativa√ß√£o para pedido ${orderId} - Sucesso: ${success}`);
            
            const order = await this.db.getOrder(orderId);
            
            if (!order) {
                this.logger.error(`Pedido ${orderId} n√£o encontrado para resultado`);
                return;
            }

            // üîá BUSCAR SESS√ÉO ANTES DE MODIFICAR
            const userSession = await this.db.getUserSession(order.chatId);
            this.logger.info(`üîá DESATIVANDO SIL√äNCIO para ${order.chatId} - resultado: ${success ? 'sucesso' : 'falha'}`);

            // üîß USAR NOME DO PRODUTO CORRETO NAS MENSAGENS
            const activatedProductName = order.selectedProductForActivation?.name || order.product.name;

            // Atualizar status do pedido
            order.status = success ? 'completed' : 'failed';
            order.result = result;
            order.error = error;
            order.completedAt = new Date().toISOString();
            
            await this.db.saveOrder(order);
            
            this.logger.info(`üîß Pedido ${orderId} atualizado - Status: ${order.status} - Produto: ${activatedProductName}`);
            
            if (success) {
                // ‚úÖ SUCESSO: SEQU√äNCIA CORRETA DE LIMPEZA
                this.logger.info(`‚úÖ Ativa√ß√£o bem-sucedida de ${activatedProductName} - Iniciando limpeza de cr√©ditos`);
                
                // üîß CORRE√á√ÉO: Limpar cr√©dito ANTES de limpar a sess√£o
                this.logger.info(`üí≥ Limpando cr√©dito para ${order.chatId} - Cr√©dito atual: R$ ${userSession.availableCredit}`);
                await this.db.clearCredit(order.chatId, 'Ativa√ß√£o bem-sucedida');
                
                // üîá DESATIVAR SIL√äNCIO - SUCESSO (AP√ìS limpar cr√©dito)
                userSession.state = null;
                userSession.currentOrderId = null;
                userSession.creditOrderId = null;
                userSession.availableCredit = 0; // üîß GARANTIR que est√° zerado
                await this.db.saveUserSession(order.chatId, userSession);
                
                this.logger.info(`üßπ Sess√£o limpa para ${order.chatId} - Cliente retorna ao estado inicial`);
                
                const messageType = 'activation_success';
                const message = this.whatsappHandler.formatMessage(messageType, {
                    product_name: activatedProductName,
                    result: result || ''
                });
                
                await this.whatsappHandler.sendMessage(order.chatId, message);
                
                this.logger.info(`‚úÖ FLUXO COMPLETO: Cliente ${order.chatId} retornou ao estado inicial sem cr√©ditos`);
                
            } else {
                // ‚ùå FALHA: Manter cr√©dito e permitir nova tentativa
                this.logger.info(`‚ùå Ativa√ß√£o de ${activatedProductName} falhou - Cliente mant√©m cr√©dito para nova tentativa`);
                
                if (userSession.availableCredit > 0) {
                    // üîá DESATIVAR SIL√äNCIO - FALHA COM CR√âDITO
                    this.logger.info(`üí≥ Restaurando sess√£o de cr√©dito para ${order.chatId}`);
                    
                    // üîß CORRE√á√ÉO: Restaurar cr√©dito se foi usado durante a tentativa
                    const originalOrder = await this.db.getOrder(userSession.creditOrderId);
                    if (originalOrder && userSession.availableCredit === 0) {
                        await this.db.grantCredit(order.chatId, originalOrder.id, originalOrder.product.price);
                        this.logger.info(`üí≥ Cr√©dito restaurado: R$ ${originalOrder.product.price}`);
                    }
                    
                    // Voltar para menu de cr√©dito
                    userSession.state = 'credit_menu';
                    await this.db.saveUserSession(order.chatId, userSession);
                    
                    // Atualizar sess√£o ap√≥s restaurar cr√©dito
                    const updatedSession = await this.db.getUserSession(order.chatId);
                    
                    // Enviar erro + menu de cr√©dito
                    const errorMessage = `‚ùå *ERRO NA ATIVA√á√ÉO*

üéØ ${activatedProductName}
‚ö†Ô∏è ${error || 'Falha na ativa√ß√£o'}

üí° *N√£o se preocupe!* Seu cr√©dito foi preservado.
Tente novamente ou escolha outro produto.

‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
üí≥ *Voc√™ ainda tem R$ ${updatedSession.availableCredit.toFixed(2)} em cr√©dito!*

Digite *menu* para ver os produtos dispon√≠veis.`;
                    
                    await this.whatsappHandler.sendMessage(order.chatId, errorMessage);
                    
                } else {
                    // üîá DESATIVAR SIL√äNCIO - FALHA SEM CR√âDITO
                    userSession.state = null;
                    userSession.currentOrderId = null;
                    await this.db.saveUserSession(order.chatId, userSession);
                    
                    // Enviar mensagem de erro
                    const errorMessage = `‚ùå *ATIVA√á√ÉO FALHOU*

üéØ ${activatedProductName}
‚ö†Ô∏è ${error || 'Falha na ativa√ß√£o'}

üí° Seu pagamento est√° seguro. Voc√™ pode:
‚Ä¢ Tentar novamente com o mesmo produto
‚Ä¢ Escolher outro produto
‚Ä¢ Entrar em contato com o suporte

Digite *menu* para fazer um novo pedido.`;
                    
                    await this.whatsappHandler.sendMessage(order.chatId, errorMessage);
                }
            }
            
        } catch (error) {
            this.logger.error('Erro ao processar resultado da ativa√ß√£o:', error);
            
            // üîá EMERG√äNCIA: Desativar sil√™ncio em caso de erro cr√≠tico
            try {
                const userSession = await this.db.getUserSession(order.chatId);
                userSession.state = null;
                await this.db.saveUserSession(order.chatId, userSession);
                
                await this.whatsappHandler.sendMessage(order.chatId, 
                    '‚ùå Erro interno no processamento. Digite *menu* para tentar novamente.'
                );
            } catch (emergencyError) {
                this.logger.error('Erro cr√≠tico no processamento:', emergencyError);
            }
        }
    }

    // Reprocessar ativa√ß√£o (para casos de falha)
    async retryActivation(orderId) {
        try {
            const order = await this.db.getOrder(orderId);
            
            if (!order) {
                return { success: false, error: 'Pedido n√£o encontrado' };
            }

            if (!order.activationData) {
                return { success: false, error: 'Dados de ativa√ß√£o n√£o encontrados' };
            }

            this.logger.info(`üîÑ Reprocessando ativa√ß√£o para pedido ${orderId}`);
            
            // Resetar status para processing
            order.status = 'processing';
            order.error = null;
            await this.db.saveOrder(order);
            
            // Tentar ativa√ß√£o novamente
            await this.sendToActivationModule(order);
            
            return { success: true, message: 'Ativa√ß√£o reprocessada' };
            
        } catch (error) {
            this.logger.error('Erro ao reprocessar ativa√ß√£o:', error);
            return { success: false, error: error.message };
        }
    }

    // Cancelar ativa√ß√£o
    async cancelActivation(orderId, reason = 'Cancelado pelo admin') {
        try {
            const order = await this.db.getOrder(orderId);
            
            if (!order) {
                return { success: false, error: 'Pedido n√£o encontrado' };
            }

            // Atualizar status para cancelado
            order.status = 'cancelled';
            order.error = reason;
            order.completedAt = new Date().toISOString();
            await this.db.saveOrder(order);
            
            // üîá DESATIVAR SIL√äNCIO SE ESTIVER ATIVO
            const userSession = await this.db.getUserSession(order.chatId);
            if (userSession.state === 'processing_activation') {
                userSession.state = null;
                userSession.currentOrderId = null;
                await this.db.saveUserSession(order.chatId, userSession);
                this.logger.info(`üîá Sil√™ncio desativado devido ao cancelamento para ${order.chatId}`);
            }
            
            // Notificar cliente
            const message = `üö´ *Ativa√ß√£o Cancelada*\n\nüéØ ${order.product.name}\nüìã Motivo: ${reason}\n\nüí¨ Entre em contato com o suporte se necess√°rio.\n\nDigite *menu* para fazer um novo pedido.`;
            
            await this.whatsappHandler.sendMessage(order.chatId, message);
            
            this.logger.info(`üö´ Ativa√ß√£o cancelada para pedido ${orderId}: ${reason}`);
            
            return { success: true, message: 'Ativa√ß√£o cancelada' };
            
        } catch (error) {
            this.logger.error('Erro ao cancelar ativa√ß√£o:', error);
            return { success: false, error: error.message };
        }
    }

    // Obter ativa√ß√µes pendentes
    async getPendingActivations() {
        try {
            const pendingOrders = await this.db.all(`
                SELECT * FROM orders 
                WHERE status IN ('processing', 'paid') 
                AND activation_data IS NOT NULL
                ORDER BY created_at ASC
            `);
            
            return pendingOrders.map(row => ({
                id: row.id,
                chatId: row.chat_id,
                product: JSON.parse(row.product_data),
                selectedProductForActivation: row.selected_product_for_activation ? JSON.parse(row.selected_product_for_activation) : null,
                activationData: row.activation_data,
                status: row.status,
                createdAt: row.created_at,
                paidAt: row.paid_at
            }));
            
        } catch (error) {
            this.logger.error('Erro ao obter ativa√ß√µes pendentes:', error);
            return [];
        }
    }

    // Obter ativa√ß√µes falhadas
    async getFailedActivations() {
        try {
            const failedOrders = await this.db.all(`
                SELECT * FROM orders 
                WHERE status = 'failed'
                ORDER BY completed_at DESC
                LIMIT 50
            `);
            
            return failedOrders.map(row => ({
                id: row.id,
                chatId: row.chat_id,
                product: JSON.parse(row.product_data),
                selectedProductForActivation: row.selected_product_for_activation ? JSON.parse(row.selected_product_for_activation) : null,
                activationData: row.activation_data,
                error: row.error,
                completedAt: row.completed_at
            }));
            
        } catch (error) {
            this.logger.error('Erro ao obter ativa√ß√µes falhadas:', error);
            return [];
        }
    }

    // Estat√≠sticas de ativa√ß√£o
    async getActivationStats() {
        try {
            const totalActivations = await this.db.get('SELECT COUNT(*) as count FROM orders WHERE status IN ("completed", "failed")');
            const successfulActivations = await this.db.get('SELECT COUNT(*) as count FROM orders WHERE status = "completed"');
            const failedActivations = await this.db.get('SELECT COUNT(*) as count FROM orders WHERE status = "failed"');
            const pendingActivations = await this.db.get('SELECT COUNT(*) as count FROM orders WHERE status IN ("processing", "paid") AND activation_data IS NOT NULL');
            
            const successRate = totalActivations.count > 0 
                ? (successfulActivations.count / totalActivations.count * 100).toFixed(2)
                : 0;
            
            return {
                total: totalActivations.count,
                successful: successfulActivations.count,
                failed: failedActivations.count,
                pending: pendingActivations.count,
                successRate: parseFloat(successRate)
            };
            
        } catch (error) {
            this.logger.error('Erro ao obter estat√≠sticas de ativa√ß√£o:', error);
            return {
                total: 0,
                successful: 0,
                failed: 0,
                pending: 0,
                successRate: 0
            };
        }
    }

    // Testar m√≥dulo de ativa√ß√£o
    async testActivationModule(moduleId) {
        try {
            if (!this.activationManager) {
                return { success: false, error: 'Activation Manager n√£o inicializado' };
            }
            
            const result = await this.activationManager.testModule(moduleId);
            return result;
            
        } catch (error) {
            this.logger.error(`Erro ao testar m√≥dulo ${moduleId}:`, error);
            return { success: false, error: error.message };
        }
    }

    // Listar m√≥dulos dispon√≠veis
    getAvailableModules() {
        if (!this.activationManager) {
            return [];
        }
        
        return this.activationManager.getAvailableModules();
    }

    // Recarregar m√≥dulos de ativa√ß√£o
    async reloadModules() {
        try {
            if (!this.activationManager) {
                return { success: false, error: 'Activation Manager n√£o inicializado' };
            }
            
            const result = await this.activationManager.reloadModules();
            this.logger.info('üîÑ M√≥dulos de ativa√ß√£o recarregados');
            return result;
            
        } catch (error) {
            this.logger.error('Erro ao recarregar m√≥dulos:', error);
            return { success: false, error: error.message };
        }
    }

    // üîá NOVO M√âTODO: For√ßar desbloqueio de usu√°rio em sil√™ncio (emerg√™ncia)
    async forceUnblockUser(chatId, reason = 'Desbloqueio for√ßado pelo admin') {
        try {
            this.logger.warn(`üîá DESBLOQUEIO FOR√áADO para ${chatId} - Motivo: ${reason}`);
            
            const userSession = await this.db.getUserSession(chatId);
            
            if (userSession.state === 'processing_activation') {
                userSession.state = null;
                await this.db.saveUserSession(chatId, userSession);
                
                await this.whatsappHandler.sendMessage(chatId, 
                    `üîì *SISTEMA DESBLOQUEADO*\n\nO processamento foi interrompido pelo administrador.\n\nDigite *menu* para continuar.`
                );
                
                this.logger.info(`üîá Usu√°rio ${chatId} desbloqueado com sucesso`);
                return { success: true, message: 'Usu√°rio desbloqueado' };
            } else {
                this.logger.info(`üîá Usu√°rio ${chatId} n√£o estava em sil√™ncio`);
                return { success: false, message: 'Usu√°rio n√£o estava em sil√™ncio' };
            }
            
        } catch (error) {
            this.logger.error('Erro ao desbloquear usu√°rio:', error);
            return { success: false, error: error.message };
        }
    }

    // üîá NOVO M√âTODO: Listar usu√°rios em sil√™ncio
    async getUsersInSilence() {
        try {
            const silentUsers = await this.db.all(`
                SELECT chat_id, state, current_order_id, updated_at 
                FROM user_sessions 
                WHERE state = 'processing_activation'
                ORDER BY updated_at DESC
            `);
            
            return silentUsers.map(user => ({
                chatId: user.chat_id.substring(0, 15) + '...',
                orderId: user.current_order_id?.substring(0, 8) + '...',
                silenceSince: user.updated_at,
                duration: Math.round((Date.now() - new Date(user.updated_at).getTime()) / 1000)
            }));
            
        } catch (error) {
            this.logger.error('Erro ao listar usu√°rios em sil√™ncio:', error);
            return [];
        }
    }

    // üîá NOVO M√âTODO: Estat√≠sticas do sil√™ncio
    async getSilenceStats() {
        try {
            const totalSilent = await this.db.get(`
                SELECT COUNT(*) as count 
                FROM user_sessions 
                WHERE state = 'processing_activation'
            `);

            const longestSilence = await this.db.get(`
                SELECT updated_at 
                FROM user_sessions 
                WHERE state = 'processing_activation' 
                ORDER BY updated_at ASC 
                LIMIT 1
            `);

            let longestDuration = 0;
            if (longestSilence) {
                longestDuration = Math.round((Date.now() - new Date(longestSilence.updated_at).getTime()) / 1000);
            }

            return {
                currentlySilent: totalSilent.count,
                longestSilenceDuration: longestDuration,
                silenceEnabled: true
            };
            
        } catch (error) {
            this.logger.error('Erro ao obter estat√≠sticas de sil√™ncio:', error);
            return {
                currentlySilent: 0,
                longestSilenceDuration: 0,
                silenceEnabled: true
            };
        }
    }
}

module.exports = ActivationService;
